// Add these calculations after the existing chartsData useMemo
// Inside the Dashboard component, after line ~300

// Filter games for current year
const currentYearGames = useMemo(() => {
  if (!games || !session?.user?.name) return [];
  const userName = session.user.name;
  const userGames = games.filter((game) => {
    const userIsWhite = game.userColor === "white" || game.white.name === userName;
    const userIsBlack = game.userColor === "black" || game.black.name === userName;
    return userIsWhite || userIsBlack;
  });
  return filterCurrentYear(userGames);
}, [games, session]);

// Best victory
const bestVictory = useMemo(() => {
  if (!session?.user?.name) return null;
  return findBestVictory(currentYearGames, session.user.name);
}, [currentYearGames, session]);

// Worst defeat  
const worstDefeat = useMemo(() => {
  if (!session?.user?.name) return null;
  return findWorstDefeat(currentYearGames, session.user.name);
}, [currentYearGames, session]);

// Play time calculation
const totalPlayTimeHours = useMemo(() => {
  let totalSeconds = 0;
  currentYearGames.forEach((game) => {
    totalSeconds += estimateGameDuration(game);
  });
  return totalSeconds / 3600; // Convert to hours
}, [currentYearGames]);

// Color performance
const colorPerformance = useMemo(() => {
  if (!session?.user?.name) return { whiteWinRate: 0, blackWinRate: 0 };
  const userName = session.user.name;
  
  let whiteGames = 0, whiteWins = 0;
  let blackGames = 0, blackWins = 0;
  
  currentYearGames.forEach((game) => {
    const userIsWhite = game.userColor === "white" || game.white.name === userName;
    const userIsBlack = game.userColor === "black" || game.black.name === userName;
    
    if (userIsWhite) {
      whiteGames++;
      if (game.result === "1-0") whiteWins++;
    } else if (userIsBlack) {
      blackGames++;
      if (game.result === "0-1") blackWins++;
    }
  });
  
  return {
    whiteWinRate: whiteGames > 0 ? Math.round((whiteWins / whiteGames) * 100) : 0,
    blackWinRate: blackGames > 0 ? Math.round((blackWins / blackGames) * 100) : 0,
  };
}, [currentYearGames, session]);

// Most frequent opponent
const frequentOpponent = useMemo(() => {
  if (!session?.user?.name) return null;
  return findMostFrequentOpponent(currentYearGames, session.user.name);
}, [currentYearGames, session]);

// Victory breakdown
const victoryBreakdown = useMemo(() => {
  if (!session?.user?.name) return { checkmate: 0, resignation: 0, timeout: 0 };
  const userName = session.user.name;
  
  let checkmate = 0, resignation = 0, timeout = 0;
  
  currentYearGames.forEach((game) => {
    const userIsWhite = game.userColor === "white" || game.white.name === userName;
    const userIsBlack = game.userColor === "black" || game.black.name === userName;
    
    // Check if user won
    const won = (userIsWhite && game.result === "1-0") || (userIsBlack && game.result === "0-1");
    if (!won) return;
    
    const termination = parseTermination(game.pgn);
    if (termination === "checkmate") checkmate++;
    else if (termination === "resignation") resignation++;
    else if (termination === "timeout") timeout++;
  });
  
  return { checkmate, resignation, timeout };
}, [currentYearGames, session]);
